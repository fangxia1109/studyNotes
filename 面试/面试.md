### 第二章 HTML

#### 第1集 说说同样是引用URL的标签属性href与src的区别是什么？

**简介：剖析src和href的区别**

- 考点：src和href的区别

- 难度【*】

- 区别

  - href

    - 表示超文本引用，指向网络资源的所在位置，用来建立当前文档和引用资源的联系

    - 浏览器会识别该文档为css文档，并行下载该文档，并且不会停止对当前文档的处理，这也是在文档中不使用@import的原因

      ```
      <link href="./style.css" rel="stylesheet" />
      ```

      ```
      <a href="https://xdclass.net" />
      ```

  - src

    - 引用资源（js脚本、图片），将目标资源下载应用到当前文档

      ```
      <script src="script.js"></script>
      ```

    - 当浏览器解析到该元素时，会暂停浏览器的渲染，直到该资源加载完毕，这也是js脚本放到底部的原因

       

- 总结

  - src用于引入文件，href用于在当前文档和引用资源之间建立联系。

 

#### 第2集 为什么引用CSS的link标签放在头部，引用JS的script标签放在body结束标签之前？

**简介：link标签和script标签的引用位置**

- 考点：页面渲染机制

- 难度【*】

- link标签放在head标签中

  - 用户访问网站时，代码是从上往下解析的，正常展示页面内容的样式，提高用户体验

  - 放在 html 结构底部时，加载页面会出现 html 结构混乱的情况

     

- script标签放在body结束标签之前

  - JS脚本在下载和执行期间会阻止 html 解析

  - 把 script 标签放在底部，保证 html和css 首先完成解析之后再加载 JS 脚本

  - script 标签加上 defer 属性时，可以放在 head 标签中 （async）

    ```
    <script defer ></script> 
    ```

     

 

 

 

 

#### 第3集 你知道如何提高一个网站的搜索权重吗？

**简介：提高网站的搜索权重**

![image-20220222143736447](https://file.xdclass.net/note/2022/77QD/img/image-20220222143736447.png)

- 考点：SEO优化、HTML语义化

- 难度【*】

- SEO优化（TDK）

  - 设置网站的 title 标题标签，如：

    ```
    <title>小滴课堂</title>
    ```

  - 设置网站的 description 描述标签，如：

    ```
    <meta name="Description" content="小滴课堂是IT技能学习平台,提供了丰富的java开发、web前端" />
    ```

  - 设置网站的 keywords 关键词标签，如：

    ```
    <meta name="keywords" content="小滴课堂 小D课堂,xdclass,java,vue教程,html教程,js教程,w3c教程,css,webpack">
    ```

- HTML语义化

  - 使用正确的标签引用正确的内容

  - 增强了可读性，结构更加清晰，便于对浏览器、搜索引擎解析

  - 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO

    ```
    header、footer、a、p、ul、ol、li、h1、h2、h3...
    ```

 

#### 第4集 如何在不同移动设备的屏幕下正常展示网页的内容？

**简介：设置移动端视口大小**

- 考点：meta标签viewport属性

- 难度【*】

- viewport

  ![image-20220224161329007](https://file.xdclass.net/note/2022/77QD/img/image-20220224161329007.png)

  - 定义

    - 手机浏览器会把页面放入到一个虚拟的视口（viewpoint）中，但 viewport 又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的视口（viewport）比屏幕宽，会把网页挤到一个很小的窗口。

       

  - 使用

    ```
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no" />
    ```

     

  - 属性

    ```
    width：设置viewport的宽度
    ```

    ```
    height：设置viewport的高度
    ```

    ```
    initial-scale：设置页面的初始缩放值
    ```

    ```
    minimum-scale：允许用户的最小缩放值
    ```

    ```
    maximum-scale：允许用户的最大缩放值
    ```

    ```
    user-scalable：是否允许用户进行缩放，no 代表不允许，yes代表允许
    ```

 

 

 

 

#### 第5集 你知道什么DOM、BOM吗？描述下这两者的区别及使用

**简介：DOM、BOM的区别与使用**

- 考点：DOM、BOM

- 难度【*】

- DOM

  - 定义

    - DOM就是⽂档对象模型，是⼀个抽象的概念

    - 定义了访问和操作HTML⽂档的⽅法和属性

       

  - 使用

    - 查找节点

      ```
      document.getElementById("xd")
      ```

    - 改变元素

      ```
      document.getElementById("xd").innerHTML = '<h1>xdclass.net</h1>';
      ```

    - 创建元素

      ```
      document.createElement('h1')
      ```

- BOM

  - 定义

    - BOM就是浏览器对象模型

    - 内置对象定义操作浏览器的方法

       

  - 使用

    - window

      ```
      window.alert('你好，小滴课堂')
      ```

    - screen

      ```
      console.log(window.screen.width)
      ```

    - location

      ```
      window.location.href
      ```

    - localStorage

      ```
      window.localStorage.setItem(key, value)
      ```

    - history

      ```
      window.history.go(1)
      ```

       

     



### 第三章 CSS

#### 第1集 你真的掌握样式优先级和选择器优先级吗？

**简介：css选择器以及优先级**

- 考点：选择器以及优先级

- 难度【**】

- 样式优先级

  - 最近的祖先样式比其他祖先样式优先级高

  - "直接样式"比"祖先样式"优先级高

  - 选择器优先级

    ```
    内联样式 > id选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器
    ```

    - 组合选择符

      - 分类

        - 后代选择符

          ```
          .a .b{}
          ```

        - 子选择符

          ```
          .a > .b{}
          ```

        - 相邻选择符

          ```
          .a + .b {}
          ```

      - 选择符优先级

        ```
        1.计算id选择器的个数（a）
        ```

        ```
        2.计算类选择器、属性选择器、伪类选择器的个数（b）
        ```

        ```
        3.计算标签选择器、伪元素选择器的个数（c）
        ```

        ```
        
        ```

        ```
        对比a、b、c的个数，相等则比较下一个
        ```

        ```
        若都相等，则按照“就近原则”比较
        ```

  - 属性后面加 !important 拥有最高优先级，若两个样式都有此设置，则对比选择器优先级

 

 

 

 

#### 第2集 说说对盒子模型的了解和实际开发中需要注意的点

**简介：介绍标准的CSS盒子模型以及低版本盒子模型异同**

- 考点：css盒子模型

- 难度【*】

  ![image-20220222144544884](https://file.xdclass.net/note/2022/77QD/img/image-20220222144544884.png)

- 盒子模型

  - 定义

    - 由内容 content + 内边距 padding + 边框 border + 外边距 margin 构成，盒子的宽高由 content + padding + border 决定，但是不同的盒子模型的计算依据不一样，分为：标准盒模型（w3c）和怪异盒模型（IE）

       

  - 标准盒模型

    - 宽高包含 content + padding + border

       

       

  - 怪异盒模型

    - 宽高只包含 content

       

  - 盒模型设置

    ```
    box-sizing:content-box // 标准盒模型
    ```

    ```
    box-sizing:border-box  // 怪异盒模型
    ```

 

 

 

 

#### 第3集 你知道CSS样式中的 BFC吗？

**简介：对块级格式化上下文的理解**

- 考点：BFC

- 难度【**】

- 什么是BFC

  - BFC就是块级格式化上下文
  - 是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响

   

- BFC 的特性

  - 内部的盒子会按照垂直方向一个个排列
  - 同一个 BFC 下的相邻块级元素会发生外边距折叠，创建新的 BFC 包含其中一个元素可以避免（解决外边距重叠）
  - 设置了 BFC 的区域不会和浮动元素重叠（解决浮动元素覆盖）
  - 当 BFC 中有浮动元素时，该浮动元素的高度也会被计算其中（解决高度塌陷）

   

- 如何触发BFC

  - 设置float浮动
  - overflow的值是hidden、auto或者scroll，而不是visible
  - position 的值为 absolute 或 fixed
  - display:table | inline-block | flex | grid

 

 

 

 

#### 第4集 说说CSS实现三栏布局的几种方式

**简介：css布局**

- 考点：css常见布局

- 难度【**】

  ![image-20220222151425955](https://file.xdclass.net/note/2022/77QD/img/image-20220222151425955.png)

- 三栏布局

  - 方案一：
    - flex布局

   

  - 方案二：

    - 浮动+margin

       

  - 方案三：

    - 浮动+BFC

       



 

 

 



#### 第5集 CSS中的预处理器有几种以及区别？

**简介：css的预处理器**

- 考点：css的预处理器

- 难度【*】

- 什么是预处理器？

  - 定义了专门的编程语言，增加了编程的特性，生成CSS文件

  - CSS代码更加简洁、适应性更强、可读性更佳，更易于代码的维护等

     

- 常见的css预处理器

  - less

  - sass

  - stylus

     

- 区别

  - 三种预处理器的使用语法都基本一致
  - 变量、嵌套、运算符、颜色函数、导入、继承等
  - stylus的写法会特别点，比如：不需要加括号

 

- 预处理器的能力

  - 嵌套反映层级和约束

  - 变量和计算减少重复代码

  - extend和mixin代码片段

  - 循环适用于复杂有规律的样式

  - import css文件模块化

     

   

 

#### 第6集 你知道几种让盒子水平垂直居中的方法？

**简介：水平垂直居中**

- 考点：CSS的居中对齐实现方式

- 难度【**】

- 方案

  - 利用flex弹性盒子

    ```
    .a{
    ```

    ```
      display:flex
    ```

    ```
      justify-content:center;
    ```

    ```
      align-items:center
    ```

    ```
    }
    ```

     

  - 利用margin与定位

    ```
    .a{
    ```

    ```
      position: relative;
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    .b{
    ```

    ```
      margin: auto;
    ```

    ```
      top: 0;
    ```

    ```
      left: 0;
    ```

    ```
      bottom: 0;
    ```

    ```
      right: 0;
    ```

    ```
      position: absolute;
    ```

    ```
    }
    ```

     

  - 利用position定位实现

    ```
    .a{
    ```

    ```
      position:relative;
    ```

    ```
    }
    ```

    ```
    .b{
    ```

    ```
      position:absolute;
    ```

    ```
      top:50%;
    ```

    ```
      left:50%;
    ```

    ```
      transform:translate(-50%,-50%);  // 未知宽高
    ```

    ```
      margin-top:-50px;   // 已知宽高
    ```

    ```
      margin-left:-50px;  // 已知宽高
    ```

    ```
    }
    ```

     

 

 

 

 

#### 第7集 你知道如何进行CSS移动端的适配吗？

**简介：CSS移动端的适配**

- 考点：CSS的移动端的适配
- 难度

- 实现

  - 第一步设置页面视口

    ```
    <meta name="viewport" 
    ```

    ```
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    ```

     

  - 第二步配置rem单位

    - 安装postcss-pxtorem，自动将 px 转换成 rem 单位的插件

      ```
      cnpm install postcss-pxtorem@5.1.1 -S
      ```

       

    - 安装amfe-flexible，自动检测当前设备屏幕宽度serveWidth，设置html里面的font-szie为serveWidth/10

      ```
      cnpm install amfe-flexible -S
      ```

       

    - 文件配置

      ```
      // vue.config.js
      ```

      ```
      module.exports = {
      ```

      ```
        css: {
      ```

      ```
          loaderOptions: {
      ```

      ```
            postcss: {
      ```

      ```
              plugins: [
      ```

      ```
                require('postcss-pxtorem')({ rootValue: 37.5 }),
      ```

      ```
              ],
      ```

      ```
            },
      ```

      ```
          },
      ```

      ```
        },
      ```

      ```
      };
      ```

      ```
      // main.js
      ```

      ```
      import 'amfe-flexible';
      ```

       

 

 

 



#### 第8集 说说你对重绘和重排的理解和如何避免？

**简介：剖析重绘和重排**

- 考点：重绘和重排
- 难度【**】
- 重绘
  - 当元素的外观、背景、颜色等改变，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘
- 重排
  - 当渲染树一部分或者全部因为大小或者边距而改变，需要渲染树重新计算的过程叫做重排
  - 重绘不一定需要重排，重排必然导致重绘
- 避免
  - 在元素的显示隐藏上尽量用 opacity 替代 visibility（重绘）
  - 元素定位时使用 transform 代替top、left（重排）
  - 尽量不使用 table 布局，因为一个小的改动会造成整个 table 重新布局（重排）
  - 减少直接操作DOM元素（重排）
  - 为元素添加类，样式都在类中改变（重绘）

 

 

 

 

 

 

#### 第9集 你真的熟悉flex布局吗？

**简介：剖析flex布局**

- 考点：flex布局

- 难度【**】

- flex布局

  - flex布局强大，能够实现多种布局方案，兼容性好，而且使用简单 （当前只列举常用的实现设置，面试够用，其他的可以看官网最新htmlcss课程中的讲解）

    ```
    /* 设置父元素 */
    ```

    ```
    display:flex
    ```

    ```
    
    ```

    ```
    /* 定义水平方向对齐方式 */
    ```

    ```
    justify-content: flex-start | flex-end | center | space-between | space-around;
    ```

    ```
    
    ```

    ```
    /* 定义垂直方向对齐方式 */
    ```

    ```
    align-items: flex-start | flex-end | center | baseline | stretch;
    ```

    ```
    
    ```

    ```
    /* 定义多个轴线（多行/多列）对齐方式 */
    ```

    ```
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
    ```

    ```
    /* 设置子元素 */
    ```

    ```
    flex:1  =>  
    ```

    ```
              flex-grow:1;  
    ```

    ```
              flex-shrink:1;  
    ```

    ```
              flex-basis:0%;
    ```

- 坑

  - 父元素设置了flex布局，默认会给每个子元素开启缩小属性（flex-shrink:1;）
  - 当空间不够时，其他的元素会被挤压至隐藏



 

 

 

 



### 第四章 应聘大厂工程师的编程语言JavaScript了解多少《上》

#### 第1集 写了多年JS代码的你知道JS的事件循环机制吗？

**简介：剖析JS事件循环**

- 考点：JS事件循环
- 难度【***】

- JavaScript语言

  - 是一门**单线程**的**非阻塞**的脚本语言

    - 为什么 JS 是一门单线程的语言？

      ```
      因为在浏览器中，需要对各种的DOM操作；
      ```

      ```
      当JS是多线程的话，如果有两个线程同时对同一个DOM进行操作，一个是在这个DOM上绑定事件，另外一个是删除该DOM，此时就会产生歧义
      ```

      ```
      因此为了保证这种事情不会发生，所以JS以单线程来执行代码，保证了一致性
      ```

       

    - JS 非阻塞应该如何理解？

      ```
      当JS代码从上往下执行，遇到需要进行一项异步任务的时候，
      ```

      ```
      主线程会挂起这个任务，继续往下执行代码，然后在异步任务返回结果的时候再根据一定规则去执行
      ```

      思考：那么这个非阻塞是如何实现的呢？此时就需要用到事件循环（event loop）

   

   

  - 事件循环

    ![image-20220222182348608](https://file.xdclass.net/note/2022/77QD/img/image-20220222182348608.png)

    - 结合代码分析事件循环

    ```
    // 同步任务
    ```

    ```
    console.log('首次同步任务开始');
    ```

    ```
    
    ```

    ```
    // 异步任务（宏任务）
    ```

    ```
    setTimeout(() => {
    ```

    ```
      console.log('setTimeout 1');
    ```

    ```
      new Promise((resolve) => {
    ```

    ```
        console.log('Promise1');
    ```

    ```
        resolve();
    ```

    ```
      }).then(() => {
    ```

    ```
        console.log('Promise then 1');
    ```

    ```
      });
    ```

    ```
    }, 1000);
    ```

    ```
    
    ```

    ```
    // 同步任务
    ```

    ```
    console.log('首次同步任务结束');
    ```

    ```
    
    ```

    ```
    // 异步任务（微任务）
    ```

    ```
    new Promise((resolve) => {
    ```

    ```
      console.log('Promise2');
    ```

    ```
      resolve();
    ```

    ```
    }).then(() => {
    ```

    ```
      console.log('Promise then 2');
    ```

    ```
    });
    ```

    - 异步任务分类：宏任务（setTimeout），微任务（promise）
    - 所有同步任务都在主线程上执行，形成一个执行栈
    - 遇到异步任务放到任务表中，等事件执行完成（ajax请求完成、setTimeout设置时间到期），之后放入到任务队列
    - 当执行栈的同步任务执行完成之后，就会执行任务队列的第一个异步任务，其中把宏观任务和微观任务都执行完成后才进行下一次循环

     

 

 

 

 

 

#### 第2集 写了多年JS代码的你知道深浅拷贝吗？

**简介：剖析深浅拷贝**

- 考点：深浅拷贝
- 难度【***】

- 深浅拷贝都是针对复杂类型数据才有的概念，基本类型数据不具备

![image-20220222190544024](https://file.xdclass.net/note/2022/77QD/img/image-20220222190544024.png)

- 浅拷贝

  - 两个引用类型指向同一个地址，改变一个，另一个也会随之改变

    ```
    var c = { num: 18 };
    ```

    ```
    var d = c;
    ```

    ```
    c.num = 20;
    ```

    ```
    console.log('c:', c, 'd:', d);
    ```

- 深拷贝

  - 复制后引用类型指向一个新的内存地址，两个对象改变互不影响

    ```
    var c = { num: 18 };
    ```

    ```
    var d = JSON.parse(JSON.stringify(c))
    ```

    ```
    c.num = 20;
    ```

    ```
    console.log('c:', c, 'd:', d);
    ```

 

- 连环问

  - 基本类型数据的赋值是浅拷贝还是深拷贝？

    ```
    赋值既不是深拷贝也不是浅拷贝，只是跟深拷贝是类似
    ```

  - 数组的方法：concat、slice是浅拷贝还是深拷贝？

    ```
    concat、slice对一维数组来说是深拷贝，多维数组的话是浅拷贝
    ```

    ```
    
    ```

    ```
    var a = [1, 2, 3];
    ```

    ```
    var b = [4, 5];
    ```

    ```
    var ab = a.concat(b);
    ```

    ```
    a = [2, 3];
    ```

    ```
    
    ```

    ```
    console.log(ab);
    ```

 

 

 

 

 

 

 

#### 第3集 你知道JS中new的作用吗？

**简介：关键字new的作用**

考点：关键字new

难度【**】

- 当没使用new关键字，直接调用构造函数时

  ```
  // 构造函数内部的this指向的是window
  ```

  ```
  function Student(obj) {
  ```

  ```
    this.name = obj.name;
  ```

  ```
    this.score = obj.score;
  ```

  ```
    this.grade = obj.grade;
  ```

  ```
    console.log(this);
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  var stu1 = Student({
  ```

  ```
    name: 'Jack',
  ```

  ```
    score: 88,
  ```

  ```
    grade: 3,
  ```

  ```
  });
  ```

  ```
  console.log(stu1);
  ```

  ```
  
  ```

  ```
  // 1.把对象返回了回来
  ```

  ```
  // 2.把构造函数的this指向了要返回的对象 
  ```

   

- new

  - 创建了新空对象

  - 将构造函数的作用域赋值给新对象(this指向新对象)

  - 执行构造函数代码 （为这个新对象添加属性）

  - 返回新对象

    ```
    function Student(obj) {
    ```

    ```
      // this={};
    ```

    ```
      this.name = obj.name;
    ```

    ```
      this.score = obj.score;
    ```

    ```
      this.grade = obj.grade;
    ```

    ```
      // return this;
    ```

    ```
    }
    ```

    ```
    var a = new Student({ name: '1', score: '2', grade: '3' });
    ```

    ```
    console.log(a);
    ```

     

 

 

 

#### 第4集 说说你对JS中的原型链的理解

**简介：剖析原型链**

考点：原型链

难度【***】

- 原型（`prototype`）

  - 是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象

    ```
    function Person() {}
    ```

    ```
    Person.prototype.name = '大钊';
    ```

    ```
    Person.prototype.a = function () {
    ```

    ```
      console.log(11);
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    var person1 = new Person();
    ```

    ```
    
    ```

    ```
    console.log(person1.name);
    ```

    ```
    person1.a();
    ```

  - 作用

    - 构造函数实例化出来的对象可以使用公共的属性或者⽅法

 

- 函数对象才有`prototype`属性

   

- 原型链

  - js⾥万物皆对象，所以⼀直访问`__proto__`属性就会产⽣⼀条链条

  - 链条的尽头是null (Object.prototype.`__proto__`)

  - 当js引擎查找对象的属性时，会先判断对象本身是否存在该属性

  - 不存在的属性就会沿着原型链往上找

    ![image-20220222215340646](https://file.xdclass.net/note/2022/77QD/img/image-20220222215340646.png)

     

    ```
    function Car() {}
    ```

    ```
    Car.prototype.name = '大钊';
    ```

    ```
    var car = new Car();
    ```

     

- 总结

  - 原型主要是解决继承问题
  - 每个对象拥有一个原型对象，通过 `__proto__` 指针指向其原型对象，并从中继承方法和属性
  - 同时原型对象也可能拥有原型，这样一层一层，最终指向 null（Object.proptotype.proto指向的是null）
  - 上述的关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法

   

 

 

 

#### 第5集 如何理解JS中的闭包

**简介：剖析闭包**

考点：闭包

难度【**】

- 思考一个计数器

  ```
  // 初始化计数器
  ```

  ```
  var a = 0;
  ```

  ```
  
  ```

  ```
  // 递增计数器的函数
  ```

  ```
  function add() {
  ```

  ```
   a++;
  ```

  ```
   console.log(a)
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  // 调⽤三次 add()
  ```

  ```
  add();
  ```

  ```
  add();
  ```

  ```
  add();
  ```

   

- 闭包

  ```
  function add() {
  ```

  ```
    var a = 0;
  ```

  ```
    return function adds() {
  ```

  ```
      a++;
  ```

  ```
      console.log(a);
  ```

  ```
    };
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  // 调⽤三次 add()
  ```

  ```
  const xd = add();
  ```

  ```
  xd();
  ```

  ```
  xd();
  ```

  ```
  xd();
  ```

  - 闭包是指有权访问另⼀个函数作⽤域中的变量的函数
  - 实现外界访问函数体内部的变量

 

 

 

 

 

 

#### 第6集 你知道JS中的执行上下文是什么吗？

**简介：剖析执行上下文**

考点：执行上下文

难度【***】

- 执行上下文

  - JS代码被解析和执行时存在的环境（ECMAscript中定义的抽象概念）

     

- 类型

  - 全局执行上下文

    - 声明在全局下的变量和函数所处的环境

  - 函数执行上下文

    - 函数每次被调用都会创建新的执行上下文，可以存在任意数量的函数执行上下文

  - eval函数执行上下文

    - 运行在eval函数中的执行上下文（用不到不做讨论）

       

- 生命周期

  - 创建阶段

    - 创建变量对象：初始化参数、提升函数声明和变量声明

    - 确定this指向

      - 源代码

        ```
        // 代码执行
        ```

        ```
        console.log(xd);
        ```

        ```
        fn();
        ```

        ```
        
        ```

        ```
        // 函数定义
        ```

        ```
        function fn() {
        ```

        ```
          console.log('你好');
        ```

        ```
        }
        ```

        ```
        
        ```

        ```
        // 变量定义
        ```

        ```
        var xd = '小滴课堂';
        ```

      - 编译后的代码

        ```
        // 声明
        ```

        ```
        function fn(){
        ```

        ```
          console.log('你好');
        ```

        ```
        }
        ```

        ```
        var xd
        ```

        ```
        
        ```

        ```
        console.log(xd);
        ```

        ```
        fn();
        ```

        ```
        
        ```

        ```
        xd = '小滴课堂';
        ```

         

- 执行阶段

  - 变量赋值
    - 代码执行
  - 回收阶段
  - 执行上下文出栈，js自动执行垃圾回收机制

 

 

 

 

 

 

#### 第7集 你知道JS中的作用域和作用域链是什么吗？

**简介：剖析作用域**

考点：作用域

难度【***】

- 作用域

  - 可访问变量，对象，函数的集合

     

- 分类

  - 全局作用域

    - 全局变量定义在函数外部，具有全局作用域

  - 函数作用域（局部作用域）

    - 局部变量定义在函数内部，具有局部作用域

  - 块级作用域（ES6的let、const）

    - 在 {} 中使用ES6的let、const方式声明，具有块级作用域

     

- 代码示例

  ```
  function A() {
  ```

  ```
    var a = 'a函数变量';
  ```

  ```
  
  ```

  ```
    function B() {
  ```

  ```
      var b = 'b函数变量';
  ```

  ```
    }
  ```

  ```
    B();
  ```

  ```
  }
  ```

  ```
  
  ```

  ```
  var c = '全局变量';
  ```

  ```
  A();
  ```

   

- 图解

  ![image-20220223173624476](https://file.xdclass.net/note/2022/77QD/img/image-20220223173624476.png)

 

- 连环问

  - 执行上下文和作用域有什么区别？

    ```
    函数定义时，作用域就已经确认了，每次函数调用时与变量的访问有关， 并且每次调用都是独立的
    ```

    ```
    而执行上下文主要是关键字this的值，这个是由函数运行时决定的，简单来说就是谁调用此函数，this就指向谁
    ```

 

 

 

 

#### 第8集 你知道改变this指向call/apply/bind的用法吗？

**简介：剖析call/apply/bind**

- 考点：call/apply/bind
- 难度【**】

- 用法

  - 三个方法都是改变this指向的

- 思考

  - 情况一

    ```
    var xd = '小滴课堂';
    ```

    ```
    function show() {
    ```

    ```
      console.log(this.xd);
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    show();  // 小滴课堂
    ```

  - 情况二

    ```
    var name = '张三';
    ```

    ```
    var age = '18';
    ```

    ```
    var obj1 = {
    ```

    ```
      name: '李四',
    ```

    ```
      say: function () {
    ```

    ```
        console.log(this.name + this.age);
    ```

    ```
      },
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    obj1.say()    // 李四 + undefined
    ```

  - 两种情况函数里的 this 指向不同，第一个 this 指向 obj，第二个是指向window

   

- 对比三者的使用

  ```
  const name = '张三';
  ```

  ```
  const age = '18';
  ```

  ```
  const obj1 = {
  ```

  ```
    name: '李四',
  ```

  ```
    fun: function () {
  ```

  ```
      console.log('名字:' + this.name + ' 年龄:' + this.age);
  ```

  ```
    },
  ```

  ```
  };
  ```

  ```
  
  ```

  ```
  const obj2 = {
  ```

  ```
    name: '王五',
  ```

  ```
    age: '19',
  ```

  ```
  };
  ```

  ```
  
  ```

  ```
  obj1.fun.call(obj2);    // 名字:王五 年龄:19
  ```

  ```
  obj1.fun.apply(obj2);   // 名字:王五 年龄:19
  ```

  ```
  obj1.fun.bind(obj2)();  // 名字:王五 年龄:19
  ```

   

- 对比三者的传参

  ```
  const name = '张三';
  ```

  ```
  const age = '18';
  ```

  ```
  const obj1 = {
  ```

  ```
    name: '李四',
  ```

  ```
    fun: function (sex, hobby) {
  ```

  ```
      console.log(
  ```

  ```
        '名字:' +
  ```

  ```
          this.name + ' 年龄:' + this.age + ' 性别:' + sex + ' 爱好:' + hobby
  ```

  ```
      );
  ```

  ```
    },
  ```

  ```
  };
  ```

  ```
  
  ```

  ```
  const obj2 = {
  ```

  ```
    name: '王五',
  ```

  ```
    age: '19',
  ```

  ```
  };
  ```

  ```
  
  ```

  ```
  obj1.fun.call(obj2, '男', '敲代码');     // 名字:王五 年龄:19 性别:男 爱好:敲代码
  ```

  ```
  obj1.fun.apply(obj2, ['男', '敲代码']);  // 名字:王五 年龄:19 性别:男 爱好:敲代码
  ```

  ```
  obj1.fun.bind(obj2, '男', '敲代码')();   // 名字:王五 年龄:19 性别:男 爱好:敲代码
  ```

   

 

 

 

 

### 第五章 应聘大厂工程师的编程语言JavaScript了解多少《下》

#### 第1集 说说JS的回调地狱是什么以及解决

**简介：JS回调地狱**

- 考点：JS回调地狱

- 难度【**】

- 回调地狱

  - 为了实现某些逻辑会写出层层嵌套的回调函数，嵌套过多会影响代码的可读性和逻辑，当某个请求失败时难以定位问题，这情况被称为回调地狱

  - 代码示例

    ```
    getData() {
    ```

    ```
      axios.get("./mock/data_a.json").then((res1) => {
    ```

    ```
        console.log(res1.data.code);
    ```

    ```
        axios.get("./mock/data_b.json").then((res2) => {
    ```

    ```
          console.log(res2.data.code);
    ```

    ```
          axios.get("./mock/data_c.json").then((res3) => {
    ```

    ```
            console.log(res3.data.code);
    ```

    ```
          });
    ```

    ```
        });
    ```

    ```
      });
    ```

    ```
    },
    ```

  - 通过promise解决

    ```
    methods:{
    ```

    ```
      getData1(url) {
    ```

    ```
        return new Promise((resolve, reject) => {
    ```

    ```
          axios.get(url).then((res1) => {
    ```

    ```
            if (res1.data.code <= 1) {
    ```

    ```
              resolve("成功");
    ```

    ```
            } else {
    ```

    ```
              reject("失败");
    ```

    ```
            }
    ```

    ```
          });
    ```

    ```
        });
    ```

    ```
      },
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    
    ```

    ```
    mounted(){
    ```

    ```
      this.getData1("./mock/data_a.json")
    ```

    ```
        .then((res) => {
    ```

    ```
          console.log(res);
    ```

    ```
          return this.getData1("./mock/data_b.json");
    ```

    ```
        })
    ```

    ```
        .then((res) => {
    ```

    ```
          console.log(res);
    ```

    ```
          return this.getData1("./mock/data_c.json");
    ```

    ```
        })
    ```

    ```
        .then((res) => {
    ```

    ```
          console.log(res);
    ```

    ```
        })
    ```

    ```
        .catch((err) => {
    ```

    ```
          console.log(err);
    ```

    ```
        });
    ```

    ```
    }
    ```

     

  - Promise.all / Promise.race

    ```
    methods:{
    ```

    ```
      getData1(url) {
    ```

    ```
        return new Promise((resolve, reject) => {
    ```

    ```
          axios.get(url).then((res1) => {
    ```

    ```
            // if (res1.data.code <= 1) {
    ```

    ```
            resolve(res1.data.code);
    ```

    ```
            // } else {
    ```

    ```
            //   reject("失败");
    ```

    ```
            // }
    ```

    ```
          });
    ```

    ```
        });
    ```

    ```
      },
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    mounted(){
    ```

    ```
      Promise.all([
    ```

    ```
      this.getData1("./mock/data_a.json"),
    ```

    ```
      this.getData1("./mock/data_b.json"),
    ```

    ```
      this.getData1("./mock/data_c.json"),
    ```

    ```
    ])
    ```

    ```
      .then((res) => {
    ```

    ```
        console.log(res);
    ```

    ```
      })
    ```

    ```
      .catch((err) => {
    ```

    ```
        console.log(err);
    ```

    ```
      });
    ```

    ```
    }
    ```

    ```
    
    ```

     

     

  - async/await解决promise链式调用不够优雅的问题

    ```
    async getData2() {
    ```

    ```
      try {
    ```

    ```
        const res1 = await this.getData1("./mock/data_a.json");
    ```

    ```
        const res2 = await this.getData1("./mock/data_b.json");
    ```

    ```
        const res3 = await this.getData1("./mock/data_c.json");
    ```

    ```
        console.log(res1, res2, res3);
    ```

    ```
      } catch (err) {
    ```

    ```
        console.log("err:", err);
    ```

    ```
      }
    ```

    ```
    },
    ```

 

 

 

#### 第2集 关于ES6语法新增了哪些高级用法？

**简介：ES6的几种好用的技巧**

- 考点：ES6语法

- 难度【*】

- let /const

  - let、const
    - let/const声明的变量只有在当前作用域有效 {}
    - 不存在变量提升
    - 不允许重复声明
  - const
    - 声明的常量不可以改变
    - 声明的常量必须赋值
    - 声明了一个对象，仅仅保证地址不变

  ```
  1.声明的变量不需要改变，那么使用const
  ```

  ```
  2.声明的变量需要改变，那么用let
  ```

  ```
  3.暂时性死区：在声明变量前，使用该变量
  ```

   

- 模板字符串 ``

  - 它为JavaScript提供了简单的字符串插值（模板字面量）功能

    ```
    let name = "小明"
    ```

    ```
    let age = '18'
    ```

    ```
    console.log('大家好，我是'+ name + '今年' + age);
    ```

    ```
    console.log(`大家好, 我是${name}今年${age}`);
    ```

- 箭头函数

  - ```
    <script>     
    ```

    ```
      function fun1(a, b) {        
    ```

    ```
        return a + b  
    ```

    ```
      }
    ```

    ```
      var fun2 = (a, b) => a + b;     
    ```

    ```
      console.log(fun1(1, 2));       
    ```

    ```
      console.log(fun2(3, 4));   
    ```

    ```
    </script>
    ```

- 解构赋值

  - 数组

    - ```
      let [a, b, c] = [1, 2, 3];
      ```

  - 对象

    - ```
      let {name,age} = {name:'小明',age:18}
      ```

      ```
      console.log(name,age)//小明,18
      ```

   

- 扩展运算符 `...`

  - ```
    console.log(...[1, 2, 3]) //1 2 3
    ```

    ```
    console.log(1, ...[2, 3, 4], 5)  //1 2 3 4 5
    ```

 

 

 

 

#### 第3集 怎么通过JS实现防抖与节流？

**简介：防抖与节流**

- 考点：防抖与节流

- 难度【**】

- 什么是防抖

  - 在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时

    - 用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源
    - window的scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次

  - 实现

    ```
    handleClick() {
    ```

    ```
      clearTimeout(this.timer);
    ```

    ```
      this.timer = setTimeout(() => {
    ```

    ```
        console.log(111);
    ```

    ```
      }, 1000);
    ```

    ```
    },
    ```

     

- 什么是节流

  - 规定一个单位时间，只能有一次触发事件的回调函数执行，如果在同一时间内某事件被触发多次，只有一次能生效

    - 鼠标连续不断地触发某事件（如点击），按照设置的时间来逐次执行；
    - 在页面的无限加载场景下，当用户频繁滚动页面时，每隔一段时间才发一次请求展示数据，而不是按照用户滚动次数来请求数据

  - 实现

    ```
    handleClick() {
    ```

    ```
      if (this.isRun) {
    ```

    ```
        return;
    ```

    ```
      }
    ```

    ```
      this.isRun = true;
    ```

    ```
      setTimeout(() => {
    ```

    ```
        this.isRun = false;
    ```

    ```
        console.log(111);
    ```

    ```
      }, 1000);
    ```

    ```
    },
    ```

     

 

 

 

#### 第4集 关于JS的设计模式了解多少？

**简介：设计模式**

- 考点：设计模式

- 难度【***】

- 单例模式

  - 确保一个类仅有一个实例，并提供一个访问它的全局访问点

    ```
    class Car {
    ```

    ```
      constructor(name) {
    ```

    ```
        this.name = name;
    ```

    ```
      }
    ```

    ```
      drive() {
    ```

    ```
        console.log('启动');
    ```

    ```
      }
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    Car.singleInstance = (function () {
    ```

    ```
      let instance;
    ```

    ```
      return function (name) {
    ```

    ```
        if (!instance) {
    ```

    ```
          instance = new Car(name);
    ```

    ```
        }
    ```

    ```
        return instance;
    ```

    ```
      };
    ```

    ```
      })();
    ```

    ```
    var benchi = Car.singleInstance('benchi');
    ```

    ```
    var baoma = Car.singleInstance('baoma');
    ```

  - 应用场景

    - 网站的登录页
    - 购物车
    - vuex

     

     

- 工厂模式

  - 工厂模式就是把实现相同功能写在函数中，需要实现相同逻辑的地方直接调用函数，减少代码重复

    ```
    function createCar(name,age){
    ```

    ```
       var obj = {}
    ```

    ```
       obj.brand = name,
    ```

    ```
       obj.color = age,
    ```

    ```
       obj.sayHelllo = function(){
    ```

    ```
        console.log('你好，小滴课堂')
    ```

    ```
      }
    ```

    ```
      return obj;
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    const car1 = createCar('宝马','白色')
    ```

    ```
    const car2 = createCar('奔驰','黑色')
    ```

     

     

 





### 第六章 当下最流行的JS框架Vue面试知多少

#### 第1集 什么是MVVM模型，说下你的理解

**简介：MVVM**

- 考点：MVVM

- 难度【*】

  ![image-20220305165347590](https://file.xdclass.net/note/2022/77QD/img/image-20220305165347590.png)

- MVVM是什么

  - 是一种设计模式，基于前端开发的架构模式
  - 核心是对View 和 Model 的双向数据绑定
  - M：Model（模型） 对应data的数据
  - V：View（视图） 页面
  - VM：ViewModel（视图模型） Vue实例对象

   

- MVVM解决了什么问题

  - 可以在Model中定义和修改数据以及操作业务逻辑
  - 实现了 Model和View的数据响应式
  - 开发者只需关注业务逻辑，复杂的数据状态维护由 MVVM 来统一管理

 

- 在vue中的MVVM（实现双向绑定原理）

  - Vue采用Object.defineProperty 的 getter 和 setter结合观察者模式实现数据绑定

     

 

#### 第2集 阐述下vue生命周期函数分别有哪些？

**简介：vue生命周期**

- 考点：vue生命周期
- 难度【*】
- 生命周期函数
  - 创建前、创建后（beforeCreate、created）
  - 挂载前、挂载后（beforeMount、mounted）
  - 更新前、更新后（beforeUpdate、updated）
  - 销毁前、销毁后（beforeDestroy、destroyed）

 

- 常用的生命周期函数
  - mounted
    - 开启定时器
    - 发送数据请求
    - 订阅消息
    - 绑定自定义事件
  - beforeDestroy
    - 清除定时器
    - 取消订阅、事件监听
    - 解绑自定义事件

 

- vue实例销毁
  - 销毁后自定义事件失效
  - 不要在beforeDestroy进行数据的操作，不会再走更新流程

 

 

 

#### 第3集 你知道指令 v-if 和 v-show 的区别吗

**简介：v-if和v-show**

- 考点：v-if和v-show
- 难度【*】
- 编译区别
  - v-if是动态的向DOM树内添加或者删除DOM元素
  - v-show是通过设置DOM元素的display样式属性控制显隐
- 编译条件
  - v-if是惰性的，当初始条件为假时，什么也不做，当条件为真时才开始局部编译;
  - v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留
- 性能消耗
  - v-if消耗大
  - v-show只有在初始渲染消耗大
- 使用场景
  - v-if不适合频繁切换
  - v-show适合频繁切换

 

 

 

 

#### 第4集 为什么 data 是一个函数而不是对象

**简介：vue的data**

- 考点：data

- 难度【*】

- 思考

  ```
  var a = {
  ```

  ```
    aa: "1",
  ```

  ```
  };
  ```

  ```
  var b = a;
  ```

  ```
  a.aa = "2";
  ```

  ```
  console.log(a, b);
  ```

- 为什么不是对象

  - 对象是引用数据类型，每个组件的data都是内存的同一个地址，那其中一个数据改变了其他也会改变
  - JavaScript只有函数构成作用域，data是一个函数时，每个组件实例都有自己的作用域

- 为什么是一个函数

  - vue中组件是用来复用的，为了防止data复用数据变量污染，将其定义为函数

  - vue组件中的`data`数据都应该是相互隔离，互不影响的，需要通过data函数返回一个对象作为组件的状态

  - 将组件中的`data`写成一个函数，数据以函数返回值形式定义，每复用一次组件，就会返回一份新的`data`，拥有自己的作用域，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据

     

   

 

 

#### 第5集 说说Computed 和 Watch 区别

**简介：Comuted和Watch的区别**

- 考点：Comuted和Watch的区别

- 难度【**】

- Computed

  - 定义

    - 通过已有的属性计算而来的

  - 写法

    - 读取/更改

      ```
      fullName: {
      ```

      ```
        get() {
      ```

      ```
          return this.firstName + '-' + this.lastName;
      ```

      ```
        },
      ```

      ```
        set(value) {
      ```

      ```
          this.firstName = value.split('-')[0];
      ```

      ```
          this.lastName = value.split('-')[1];
      ```

      ```
        },
      ```

      ```
      },
      ```

    - 读取简写

      ```
      computed: {
      ```

      ```
        fullName() {
      ```

      ```
          return this.firstName + '-' + this.lastName;
      ```

      ```
        },
      ```

      ```
      }
      ```

      ```
      
      ```

      ```
      // 注意：只有当只读时可以简写，有修改需求时不能使用简写
      ```

  - 优点

    - 有缓存的机制，可以复用

    - 效率高，调试方便

       

- Watch

  - 通过监视属性实现姓名拼接

    ```
     watch: {
    ```

    ```
      firstName: function (val) {
    ```

    ```
        this.fullName = val + '-' + this.lastName;
    ```

    ```
      },
    ```

    ```
      lastName: function (val) {
    ```

    ```
        this.fullName = this.frstName + '-' + val;
    ```

    ```
      },
    ```

    ```
    }
    ```

  - 异同

    - 监视属性是命令式且重复的
    - 通过计算属性实现更加简介明了
    - 两者都能实现的，优先选择使用computed
    - watch能实现异步调用，computed不能

  ![13](https://file.xdclass.net/note/2022/77QD/img/13.png)

 

 

#### 第6集 vue的组件通讯方式有几种？

**简介：组件通信**

- 考点：组件通信

- 难度【**】

- 通讯方式

  - 父子组件传值

    - 父向子传值

      - `props`

        ```
        // 只接收
        ```

        ```
        props: ["xd"]
        ```

        ```
        
        ```

        ```
        // 限制类型
        ```

        ```
        props: { xd: String }
        ```

      - 注意

        - props的数据时单向的，只能从父组件传到子组件
        - props的数据不可更改，如果要更改需备份到data中做操作

       

    - 子向父传值

      - 调用父组件定义的方法传参

        - 函数传值

          ```
          // 父组件
          ```

          ```
          <xd-home :dianji="dianji" />
          ```

          ```
          
          ```

          ```
          methods:{
          ```

          ```
            dianji(i){
          ```

          ```
              console.log(i)
          ```

          ```
            }
          ```

          ```
          }
          ```

          ```
          // 子组件
          ```

          ```
          props:['dianji']
          ```

          ```
          
          ```

          ```
          data(){
          ```

          ```
            name:'子组件数据'
          ```

          ```
          }
          ```

          ```
          
          ```

          ```
          methods:{
          ```

          ```
            dianji_xd() {
          ```

          ```
              this.dianji(this.name);
          ```

          ```
            },
          ```

          ```
          }
          ```

           

        - 自定义事件（@绑定）

          ```
          // 父组件
          ```

          ```
          <xd-home @myXd="dianji" />
          ```

          ```
            
          ```

          ```
          methods:{
          ```

          ```
            dianji(i){
          ```

          ```
              console.log(i)
          ```

          ```
            }
          ```

          ```
          }
          ```

          ```
          // 子组件
          ```

          ```
          data(){
          ```

          ```
            name:'子组件数据'
          ```

          ```
          }
          ```

          ```
          dianji_xd() {
          ```

          ```
            this.$emit("myXd", this.name);
          ```

          ```
          },
          ```

           

  - Provide/inject

    ```
    // 父组件
    ```

    ```
    export default {
    ```

    ```
      provide: {
    ```

    ```
        name: '浪里行舟'
    ```

    ```
      }
    ```

    ```
    }
    ```

    ```
    // 孙子组件
    ```

    ```
    export default {
    ```

    ```
      inject: ['name'],
    ```

    ```
      mounted () {
    ```

    ```
        console.log(this.name);  // 浪里行舟
    ```

    ```
      }
    ```

    ```
    }
    ```

   

   

  - 全局事件总线

    - 安装全局事件总线

      ```
      new Vue({
      ```

      ```
        ...
      ```

      ```
        beforeCreate(){
      ```

      ```
          Vue.prototype.$bus = this
      ```

      ```
        }
      ```

      ```
        ...
      ```

      ```
      })
      ```

    - 提供数据的组件

      ```
      this.$bus.$emit('xx',数据)
      ```

       

    - 在需要接收数据的组件绑定自定义事件

      ```
      methods:{
      ```

      ```
       xd(i){
      ```

      ```
         console.log(i)
      ```

      ```
       }
      ```

      ```
      }
      ```

      ```
      mounted(){
      ```

      ```
       this.$bus.$on('xx',this.xd)
      ```

      ```
      }
      ```

       

    - 解绑

      ```
      this.$bus.$off()
      ```

    

  - 状态管理库vuex

     

 

 

 

#### 第7集 你知道vue中是如何路由传参吗？

**简介：vue的路由传参**

- 考点：vue路由传参

- 难度【**】

- query传参

  - 字符串

    ```
    <router-link :to="`/home?text=${text}`" >
    ```

    ```
      首页
    ```

    ```
    </router-link>
    ```

  - 对象

    ```
    <router-link :to="{ path: '/home', query: { text: text } }">
    ```

    ```
      首页
    ```

    ```
    </router-link>
    ```

  - 获取

    ```
    this.$route.query.text
    ```

   

- params 传参

  - 路由器声明 params 传参

    ```
    {
    ```

    ```
      name: 'shouye',
    ```

    ```
      path: 'home/:text', //字符串形式传参时需加占位符告知路由器，此时是参数
    ```

    ```
      component: Home,
    ```

    ```
    },
    ```

  - 字符串

    ```
    <router-link :to="`/home${text}`">
    ```

    ```
      首页
    ```

    ```
    </router-link>
    ```

  - 对象

    ```
    <router-link :to="{ name: 'shouye', params: { text: text } }">
    ```

    ```
      首页
    ```

    ```
    </router-link>
    ```

  - 获取

    ```
    this.$route.params.text
    ```

  - 注意

    - 字符串形式传参时需加占位符告知路由器， 在路径后面是参数
    - path对应的是 query属性，name 对应的是 params 属性

     

   

- 编程式路由导航

  - 写法

    ```
    this.$router.push({
    ```

    ```
      path: "/home",
    ```

    ```
      query: {
    ```

    ```
        text: this.text,
    ```

    ```
      },
    ```

    ```
    });
    ```

     

   

 

 

#### 第8集 说说vue是如何监听对象和数组变化的

**简介：vue监听对象和数组的变化**

- 考点：vue监听对象和数组变化

- 难度【***】

- vue中对象数据的更新问题

  - 对象新增数据更新问题

    - 描述

      - 通过普通对象添加属性方法，Vue不能监测到且不是响应式

        ```
        this.obj.name= '小滴课堂'
        ```

    - 解决

      - this.$set

        ```
        this.$set(this.obj,'name','小滴课堂')
        ```

      - 注意

        this.$set不能给vue实例的根数据对象添加属性

   

  - 数组数据更新问题

    - 描述

      - 直接通过数组索引值改变数组的数据，Vue监测不到改变

      - 实际在 `js` 内存已经把数据的第一项数据修改了

        ```
        this.list[0] = { name: '李四',age: 20 };
        ```

    - 解决

      - Vue在数组的原始操作方法上包裹了重新解析模板的方法，

        也就是说我们在data里面的数组操作方法不是原生的，是vue封装过的

      - 哪些数组操作方法经过了封装？

        ```
        push() 
        ```

        ```
        pop()
        ```

        ```
        shift()
        ```

        ```
        unshift()
        ```

        ```
        splice()
        ```

        ```
        sort()
        ```

        ```
        reverse()
        ```

  

#### 第9集 说下vue的响应式原理是如何实现的？

**简介：Vue的响应式原理**

- 考点：Vue的响应式原理

- 难度【***】

- 原理（ Object.defineProperty() ）

  - 通过一个对象代理另一个对象属性的读写

    ```
    Object.defineProperty('代理对象', '代理属性', {
    ```

    ```
      get() {             // getter   当读取’目标对象‘的’代理属性‘时，get函数/getter就会被调用，且返回代理属性的值
    ```

    ```
        return xxx;       
    ```

    ```
      },
    ```

    ```
      set(value) {        // setter   当修改’目标对象‘的’代理属性‘时，set函数/setter就会被调用，且收到修改的值
    ```

    ```
        xxx;
    ```

    ```
      },
    ```

    ```
    });
    ```

    ```
    let obj1 = {
    ```

    ```
      a: 111,
    ```

    ```
    };
    ```

    ```
    let obj2 = {};
    ```

    ```
    Object.defineProperty(obj2, 'a', {
    ```

    ```
      get() {
    ```

    ```
        console.log('obj2被读取了');
    ```

    ```
        return obj1.a;
    ```

    ```
      },
    ```

    ```
      set(value) {
    ```

    ```
        console.log('obj2被修改了');
    ```

    ```
        obj1.a = value;
    ```

    ```
      },
    ```

    ```
    });
    ```

- Vue中应用的数据代理

  - 通过vm对象属性代理 _data 中属性的读写
  - 能更加方便的读写vue中data的数据
  - 通过`Object.defineProperty()`把 data 中的属性添加到vm对象上，每个属性都有setter/getter

 

- 连环问

  - 说下vue3的响应式原理是如何实现的，为什么？

    - Object.defineProperty

      - 无法监听新增属性和删除属性，使用this.$set
      - 深层对象的劫持需要递归
      - 劫持数组时需要重写数组原生操作方法
      - 只是对对象的属性进行劫持

    - Proxy

      - 概述

        正如Proxy的英译"代理"所示，Proxy是ES6为了操作对象引入的API。它不直接作用在对象上，而是作为一种媒介，如果需要操作对象的话，需要经过这个媒介的同意。

      - 使用方式

        ```
        let p = new Proxy(target, handler)
        ```

        ```
        //target: 目标对象
        ```

        ```
        //handler: 对对象进行拦截操作的函数，如set、get
        ```

      - 使用场景

        ```
        const house = {
        ```

        ```
          name: '张三',
        ```

        ```
          price: '1000',
        ```

        ```
          phone: '18823139921',
        ```

        ```
          id: '111',
        ```

        ```
          state: '**',
        ```

        ```
        };
        ```

        ```
        
        ```

        ```
        const houseProxy = new Proxy(house, {
        ```

        ```
          // 读取代理
        ```

        ```
          get: function (target, key) {
        ```

        ```
            switch (key) {
        ```

        ```
              case 'phone':
        ```

        ```
                return '抱歉，不能告知'
        ```

        ```
              default:
        ```

        ```
                return Reflect.get(target,key);
        ```

        ```
            }
        ```

        ```
          },
        ```

        ```
          // 设置代理
        ```

        ```
          set: function (target, key, value) {
        ```

        ```
            if (key === 'id') {
        ```

        ```
              return Reflect.get(target,key);  
        ```

        ```
            } else if (key === 'state') {
        ```

        ```
              return Reflect.set(target,key,value);
        ```

        ```
            }
        ```

        ```
          },
        ```

        ```
        });
        ```

        ```
        
        ```

        ```
        console.log(houseProxy.price);
        ```

        ```
        console.log(houseProxy.phone);
        ```

        ```
        
        ```

        ```
        houseProxy.id = '222';
        ```

        ```
        houseProxy.state = '****';
        ```

        ```
        console.log(houseProxy.id);
        ```

        ```
        console.log(houseProxy.state);
        ```

      - Reflect（映射）

        - 规范化、语义化
        - ES6规范中为了操作对象更加趋向于编程式（函数式）
        - 减少异常的抛出，因为对象的属性有可能是个getter或者setter
        - Reflect对象的方法与Proxy对象的方法一一对应

     

 

 

 

 

#### 第10集 你知道状态管理库Vuex的使用和应用场景吗？

**简介：状态管理库Vuex使用**

- 考点：状态管理库Vuex使用

- 难度【***】

- 定义

  - Vuex 是采用集中式存储管理所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
  - 应用遇到多个组件共享状态时，使用Vuex

- 场景：多个组件共享数据或者是跨组件传递数据时

- Vuex的属性

  - state

    - vuex的基本数据，用来存储变量

      ```
      $store.state.xd
      ```

       

  - action

    - action 提交的是 mutation，而不是直接变更状态，action 可以包含任意异步操作

      ```
      change(context, value) {
      ```

      ```
        context.commit('CHANGE', value);
      ```

      ```
      }
      ```

     

  - mutation

    - 提交更新数据的方法，必须是同步的

    - 每个mutation 都有一个字符串的事件类型和一个回调函数。

    - 回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，传入变更值作为第二个参数。

      ```
      CHANGE(state, value) {
      ```

      ```
        state.xd = value;
      ```

      ```
      }
      ```

       

  - getters

    - 从基本数据(state)派生的数据，相当于state的计算属性

      ```
      add() {
      ```

      ```
        return state.xd + 1;
      ```

      ```
      }
      ```

       

  - modules

    - 模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理

      ```
      export default new Vuex.Store({
      ```

      ```
        modules: {
      ```

      ```
          count,
      ```

      ```
        },
      ```

      ```
      });
      ```

       

   

- Vuex的流程

  ```
  1.页面通过提交事件到action
  ```

  ```
  2.action通过commit把对应参数同步提交到mutation
  ```

  ```
  3.mutation会修改state中对应的值
  ```

  ```
  4.getter：将数据state进行处理，相当于组件中的计算属性
  ```

 

 

 

 

 

 

 

### 第七章 面试大厂必问的react框架知多少

#### 第1集 说说什么是react和vue的区别？

**简介：react理解**

- 考点：react的理解

- 难度【*】

- 特性

  - react 是一个起源于Facebook 内部开源的网页UI框架，构建用户界面的JavaScript 库

  - react内部使用jsx语法，执行速度快，用html的语法来定义虚拟DOM，编写模板更加简单

  - 使用虚拟DOM的diff算法来操作真实DOM元素，减少不必要的渲染

  - 声明式编程，一切皆为组件

     

- 相同点

  - 两个都是js框架，使用虚拟DOM

  - 数据驱动页面，提供响应式的视图组件

  - 都有自己的构建工具

  - 都有状态管理库，React有redux，Vue有自己的Vuex

     

- 不同点

  - 数据绑定：vue实现了双向的数据绑定，react数据流动是单向的
  - 使用场景：react配合redux架构适合大规模多人协作复杂项目，vue适合小快的项目
  - 灵活性：react比较灵活，拥有强大社区，vue更多的是拥有自己的指令

 

 

 

 

 

 

#### 第2集 为什么虚拟 DOM 会提高渲染性能?

**简介：虚拟 dom**

- 考点：虚拟 dom

- 难度【**】

- 虚拟DOM

  - 代码示例
  - jsx 是 React.createElement函数的语法糖
  - babel官网： https://babeljs.io/repl/#?presets=react

  - 未使用虚拟DOM之前的渲染

    ```
     state数据 ==> 数据+模板结合，生成真实DOM ==> state改变 ==> 数据+模板结合，生成新的真实DOM，替换原始的DOM
    ```

  - 使用虚拟DOM之后的渲染

    ```
    state数据 ==> creatElement/jsx生成虚拟DOM ==> 生成真实DOM ==> state改变 ==> 新的虚拟dom与原始虚拟DOM对比（diff算法）==> 有差异的真实DOM
    ```

  - 虚拟DOM优势

    - 直接操作真实DOM性能消耗大：绑定的事件、属性、重绘、重排
    - 虚拟DOM对比（diff算法）把改变的节点构建成真实DOM，减少不必要的渲染

 

 

 

 

 

#### 第3集 怎么区分有状态和无状态组件？

**简介：有状态和无状态组件**

- 考点：有状态和无状态组件

- 难度【**】

- 无状态组件

  - 纯静态展示的组件

  - 基本是接受父组件的props和render函数组成

  - 不涉及到状态state的更新，这种组件的复用性很强

     

- 有状态组件

  - 组件内部包含state且会随着事件、生命周期或者外部的消息发生改变，就叫有状态组件
  - 有状态组件会带有生命周期，在不同的时刻触发状态的更新

   

 

 

 

 

 

 

 

 

 

#### 第4集 你知道setState是同步还是异步吗？

**简介：理解setState的使用**

- 考点：setState的使用

- 难度【**】

- setState既可以是异步也可以是同步的，在不同的场景下表现不同

  - 异步

    - 合成事件（onClick、onChange）

      ```
      import React, { Component } from 'react';
      ```

      ```
      
      ```

      ```
      class Test extends Component {
      ```

      ```
        state = { xd: 0 };
      ```

      ```
      
      ```

      ```
        handleClick = () => {
      ```

      ```
          this.setState({ xd: this.state.xd + 1 });
      ```

      ```
          console.log(this.state.xd);
      ```

      ```
        };
      ```

      ```
        render() {
      ```

      ```
          return <div onClick={this.handleClick}>{`点击次数: ${this.state.xd}`}</div>;
      ```

      ```
        }
      ```

      ```
      }
      ```

      ```
      
      ```

      ```
      export default Test;
      ```

    - 生命周期函数

      ```
      componentDidMount() {
      ```

      ```
        this.setState({ xd: this.state.xd + 1 });
      ```

      ```
        console.log(this.state.xd);
      ```

      ```
      }
      ```

       

  - 同步

    - 原生事件

      ```
      handleClick = () => {
      ```

      ```
        this.setState({ xd: this.state.xd + 1 });
      ```

      ```
        console.log(this.state.xd);
      ```

      ```
      };
      ```

      ```
      componentDidMount() {
      ```

      ```
        document.body.addEventListener('click', this.handleClick);
      ```

      ```
      }
      ```

    - setTimeout函数

      ```
      componentDidMount() {
      ```

      ```
        setTimeout(() => {
      ```

      ```
          this.setState({ xd: this.state.xd + 1 });
      ```

      ```
          console.log(this.state.xd);
      ```

      ```
        }, 1000);
      ```

      ```
      }
      ```

     

  - setState的批量更新（异步）

    ```
    class Test extends Component {
    ```

    ```
      state = { xd: 0 };
    ```

    ```
    
    ```

    ```
      componentDidMount() {
    ```

    ```
        this.setState({ xd: this.state.xd + 1 });
    ```

    ```
        console.log(this.state.xd);
    ```

    ```
    
    ```

    ```
        this.setState({ xd: this.state.xd + 1 });
    ```

    ```
        console.log(this.state.xd);
    ```

    ```
    
    ```

    ```
        setTimeout(() => {
    ```

    ```
          this.setState({ xd: this.state.xd + 1 });
    ```

    ```
          console.log(this.state.xd);
    ```

    ```
    
    ```

    ```
          this.setState({ xd: this.state.xd + 1 });
    ```

    ```
          console.log(this.state.xd);
    ```

    ```
        }, 1000);
    ```

    ```
      }
    ```

    ```
    
    ```

    ```
      render() {
    ```

    ```
        return <div>{this.state.xd}</div>;
    ```

    ```
      }
    ```

    ```
    }
    ```

 

 

 

 

 

#### 第5集 你知道react中diff算法的原理吗？

**简介：理解diff算法**

- 考点：diff算法

- 难度【***】

-  

  ![image-20220311133044187](https://file.xdclass.net/note/2022/77QD/img/image-20220311133044187.png)

   

   

  ![image-20220311133533882](https://file.xdclass.net/note/2022/77QD/img/image-20220311133533882.png)

 

- 数据更新时新旧虚拟DOM进行对比

  - 同级节点进行对比，如果类型相同则继续往下对比
  - 如果类型不相同，则直接删除当前节点下的所有节点，替换成新的虚拟DOM构建真实DOM

- 数据更新时，阻止不需要对比或者重新渲染的节点

  - class组件通过shouldComponentUpdate方法判断当前节点是否要进行对比

  - 函数组件通过useMemo、useCallback这两个hook来判断

     

- diff算法key的作用

  - index作为key值时

  改变前： ![image-20220311144935613](https://file.xdclass.net/note/2022/77QD/img/image-20220311144935613.png) 改变后： ![image-20220311144959571](https://file.xdclass.net/note/2022/77QD/img/image-20220311144959571.png)

 

 

- ![image-20220311140859778](https://file.xdclass.net/note/2022/77QD/img/image-20220311140859778.png)

   

   

   

  - 固定key值

![image-20220311140924533](https://file.xdclass.net/note/2022/77QD/img/image-20220311140924533.png)

 

 

 

 

 

 

#### 第6集 react中的高阶组件是什么？

**简介：理解高阶组件**

- 考点：高阶组件

- 难度【***】

- 定义

  - 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件

- 应用场景

  - 业务开发过程中可能会遇到一些个性化的需求，此时如果再去重新开发一个组件，会让后续的维护成本变高。

     

    ![image-20220312220850982](https://file.xdclass.net/note/2022/77QD/img/image-20220312220850982.png)

- 代码示例

- 原始组件

  - 父组件

    ```
    import GeneralComponents from './GeneralComponents';
    ```

    ```
    
    ```

    ```
    const ComponentOne = () => {
    ```

    ```
      return (
    ```

    ```
        <div>
    ```

    ```
          组件一
    ```

    ```
          <GeneralComponents />
    ```

    ```
        </div>
    ```

    ```
      );
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default ComponentOne;
    ```

  - 通用组件

    ```
    const GeneralComponents = () => {
    ```

    ```
      return (
    ```

    ```
        <div style={{ backgroundColor: 'red', width: '200px' }}>通用的组件</div>
    ```

    ```
      );
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default GeneralComponents;
    ```

- 新增/改造原有组件逻辑

  - 新增的组件二

    ```
    import HigherOrderComponent from './HigherOrderComponent';
    ```

    ```
    import GeneralComponents from './GeneralComponents';
    ```

    ```
    
    ```

    ```
    const ComponentTwo = () => {
    ```

    ```
      return (
    ```

    ```
        <div>
    ```

    ```
          组件二
    ```

    ```
          <HigherOrderComponent Subcomponent={<GeneralComponents />} />
    ```

    ```
        </div>
    ```

    ```
      );
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default ComponentTwo;
    ```

  - 高阶组件（增加计数器）

    ```
    import { useState } from 'react';
    ```

    ```
    
    ```

    ```
    const HigherOrderComponent = ({ Subcomponent }) => {
    ```

    ```
      const [xd, setXd] = useState(1);
    ```

    ```
    
    ```

    ```
      return (
    ```

    ```
        <div>
    ```

    ```
          <h1 onClick={() => setXd(xd + 1)}>{xd}</h1>
    ```

    ```
          {Subcomponent}
    ```

    ```
        </div>
    ```

    ```
      );
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default HigherOrderComponent;
    ```

     

   

 

 

 

 

#### 第7集 说下状态管理库redux工作机制

**简介：理解redux**

- 考点：redux
- 难度【***】
- 应用场景
  - 业务逻辑比较复杂
  - 涉及频繁的组件间的传值
  - 组件需要维护的状态比较多
- redux作用

![image-20220311181005161](https://file.xdclass.net/note/2022/77QD/img/image-20220311181005161.png)



- redux工作流程

 

 

![image-20220313144226657](https://file.xdclass.net/note/2022/77QD/img/image-20220313144226657.png)

 

- redux使用

  - 创建管理员（store）

    ```
    // store/index.js
    ```

    ```
    import { createStore } from 'redux';
    ```

    ```
    import reducer from './reducer';
    ```

    ```
    
    ```

    ```
    const store = createStore(reducer);
    ```

    ```
    
    ```

    ```
    export default store;
    ```

  - 创建书本库存记录表（reducer）

    ```
    const defaultState = {
    ```

    ```
      book: '葵花宝典',
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    const reducer = (state = defaultState, action) => {
    ```

    ```
      if (action.type === 'change') {
    ```

    ```
        const newState = JSON.parse(JSON.stringify(state));
    ```

    ```
        newState.book = '九阳神功';
    ```

    ```
        return newState;
    ```

    ```
      }
    ```

    ```
      return state;
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default reducer;
    ```

  - 获取库存信息（获取state）

    ```
    import React, { useState } from 'react';
    ```

    ```
    import store from '../store';
    ```

    ```
    
    ```

    ```
    const GetBook = () => {
    ```

    ```
      const [book, setBook] = useState(store.getState().book);
    ```

    ```
      store.subscribe(() => setBook(store.getState().book));
    ```

    ```
      return <div>{book}</div>;
    ```

    ```
    };
    ```

    ```
    export default GetBook;
    ```

  - 购买（提交action）

    ```
    store.dispatch({
    ```

    ```
      type: 'change',
    ```

    ```
    });
    ```

     

 

 

 

 

 

#### 第8集 react使用hooks的优势？

**简介：理解hooks**

- 考点：hooks

- 难度【***】

- hooks 的优势

  - 使用函数组件时引入hooks，让组件的写法更加轻量、灵活性更高
  - 不需要继承class对象、生命周期、繁琐的this指向问题
  - 可读性强，更好地复用组件，提取逻辑更容易

- 代码示例

  - 类组件

    ```
    import React, { Component } from 'react';
    ```

    ```
    
    ```

    ```
    class CountClass extends Component {
    ```

    ```
      state = { count: 1 };
    ```

    ```
    
    ```

    ```
      countAdd = () => {
    ```

    ```
        this.setState({ count: this.state.count + 1 });
    ```

    ```
      };
    ```

    ```
    
    ```

    ```
      componentDidMount() {
    ```

    ```
        document.body.addEventListener('click', this.countAdd);
    ```

    ```
      }
    ```

    ```
    
    ```

    ```
      componentDidUpdate() {
    ```

    ```
        console.log('数据更新了');
    ```

    ```
      }
    ```

    ```
    
    ```

    ```
      componentWillUnmount() {
    ```

    ```
        console.log('类组件销毁了');
    ```

    ```
        document.body.removeEventListener('click', this.countAdd);
    ```

    ```
      }
    ```

    ```
    
    ```

    ```
      render() {
    ```

    ```
        return (
    ```

    ```
          <div style={{ backgroundColor: 'pink' }}>
    ```

    ```
            <div>屏幕点击次数： {this.state.count}</div>
    ```

    ```
          </div>
    ```

    ```
        );
    ```

    ```
      }
    ```

    ```
    }
    ```

    ```
    
    ```

    ```
    export default CountClass;
    ```

  - 函数组件

    ```
    import { useState, useEffect } from 'react';
    ```

    ```
    
    ```

    ```
    const CountFun = () => {
    ```

    ```
      const [count, setCount] = useState(1);
    ```

    ```
      const countAdd = () => {
    ```

    ```
        setCount((count) => count + 1);
    ```

    ```
      };
    ```

    ```
      useEffect(() => {
    ```

    ```
        document.body.addEventListener('click', countAdd);
    ```

    ```
        return () => {
    ```

    ```
          console.log('函数组件销毁了');
    ```

    ```
          document.body.removeEventListener('click', countAdd);
    ```

    ```
        };
    ```

    ```
      }, []);
    ```

    ```
      return (
    ```

    ```
        <div style={{ backgroundColor: 'lightblue' }}>
    ```

    ```
          <div>屏幕点击次数：{count}</div>
    ```

    ```
        </div>
    ```

    ```
      );
    ```

    ```
    };
    ```

    ```
    
    ```

    ```
    export default CountFun;
    ```

    - useReducer
      - 对于复杂的业务逻辑或者复杂多层级的state可使用useReducer
    - useContext
      - 实现不同组件间的数据共享
    - 自定义hooks

 

 

 

 

#### 第9集 减少组件的重复渲染useMemo和useCallback的使用

**简介：理解useMemo和useCallback**

- 考点：useMemo和useCallback

- 难度【***】

- useMemo

  - 在第一次渲染执行，把返回值缓存起来，并监控一个变量，变量不变则返回值不变

    ```
    const newXd = useMemo(() => {
    ```

    ```
      console.log(111);
    ```

    ```
      return xd;
    ```

    ```
    }, [xd]);
    ```

  - 结合 memo 减少组件的不必要渲染，依赖的变量变化时再次执行，返回计算值

    ```
    const Test = memo(({ xd }) => {
    ```

    ```
      console.log('Test组件渲染了');
    ```

    ```
      return <div>{xd}</div>;
    ```

    ```
    }); 
    ```

     

- useCallback（结合memo）

  - 在第一次渲染执行，把函数缓存起来，并监控一个变量，变量不变则返回函数不变

    ```
    const handleClicks=useCallback(()=>{
    ```

    ```
      // 你要做的事情
    ```

    ```
    },[xd]) 
    ```

  - 结合 memo 实现组件的重复渲染

    ```
    const Test = memo(({ handleClicks }) => {
    ```

    ```
      console.log('Test组件渲染了');
    ```

    ```
      return <div onClcik={handleClicks}>'小滴课堂'</div>;
    ```

    ```
    });
    ```

     

 

 

 

 

### 第八章 最接近用户的协议-Http协议

#### 第1集 B/S架构和C/S架构你知道多少

- 什么是CS架构 客户机-服务器模式，即Client-Server(C/S)结构 但是缺少通用性，系统维护、升级需要重新设计和开发，增加了维护和管理的难度
- 什么是BS架构 B/S架构即浏览器和服务器架构模式，是WEB兴起后的一种网络架构模式 WEB浏览器是客户端最主要的应用软件 统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用

![image-20200523220113626](https://file.xdclass.net/note/2022/77QD/img/%E2%80%98.png)

- 什么是URL（统⼀资源定位符，获取服务器资源的一种）

  - 标准格式: 协议://服务器IP:端⼝/路径1/路径N ? key1=value1 & key2=value2
    - 协议：不同的协议有不同的解析⽅式
    - 服务器ip: ⽹络中存在⽆数的主机,要访问的哪⼀台, 通过公⽹ip区分
    - 端⼝: ⼀台主机上运⾏着很多的进程，为了区分不同进程，⼀个端⼝对应⼀个进程，http默认的端⼝是80
    - 路径: 资源N多种，为了更进⼀步区分资源所在的路径（后端接⼝，⼀般称为 “接⼝路径”，“接⼝”）

   

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 第2集 什么是HyperText Transfer Protocol 超文本传输协议

**简介：什么是Http超文本传输协议**

- 协议

  - 协议是⼀种约定，规定好⼀种信息的格式，如果发送⽅按照这种请求格式发送信息，那么接 收端就要按照这样的格式解析数据，这就是协议

  - json协议

    ```
    {
    ```

    ```
        "name":"jack",
    ```

    ```
        "age":23
    ```

    ```
    }
    ```

     

  - xml协议

    ```
    <user>
    ```

    ```
      <name> jack </name>
    ```

    ```
      <age> 23 </age>
    ```

    ```
    </user>
    ```

     

  - http超文本传输协议

 

- 什么是http协议

  - 即超⽂本传送协议，是Web联⽹的基础，也是⼿机PC联⽹常⽤的协议之⼀，HTTP协议是建⽴在TCP协议之上的⼀种应⽤
  - HTTP连接最显著的特点是客户端发送的每次请求都需要服务器响应请求，从建⽴连接到关闭连接的过程称为“⼀次连接”
  - HTTP请求-HTTP响应
  - 响应码：
    - 2xx:成功 200 OK，请求正常
    - 3xx:重定向
    - 4xx:客户端错误 404 Not Found 服务器⽆法找到被请求的⻚⾯
    - 5xx:服务器错误 503 Service Unavailable，服务器挂了或者不 可⽤

- 发展历史

  - http0.9-》http1.0-》http1.1-》http2.0

  - 优化协议，增加更多功能

     

- http和https协议的主要区别
  - https协议需要CA证书，费用较高；http协议不需要
  - http协议是超文本传输协议，信息是明文传输的，https则是具有安全性的`SSL`加密传输协议
  - 使用的连接方式不同，端口也不同，http协议端口是80，https协议端口是443
  - http协议连接很简单，是无状态的；https协议是有SSL和 TLS协议构建的可进行加密传输、身份认证的网络协议，比http更加安全
- https优点
  - https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
  - https协议是由`SSL`+`HTTP`协议构建的可进行加密传输、身份认证的网络协议，要比`HTTP`协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
  - https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 第3集 超文本传输协议Http消息体拆分讲解

**简介：讲解Http协议消息体拆分讲解**

- Http请求消息结构 （请求的报文）

  - 请求行
    - 请求方法
    - URL地址
    - 协议名
  - 请求头
    - 报文头包含若干个属性 格式为“属性名:属性值”，
    - 服务端据此获取客户端的基本信息
  - 请求体
    - 请求的参数，可以是json对象，也可以是前端表单生成的key=value&key=value的字符串

  ![image-20200523224136206](https://file.xdclass.net/note/2022/77QD/img/image-20200523224136206.png)

- Http响应消息结构（响应的报文）

  - 响应行
    - 报文协议及版本、状态码
  - 响应头
    - 报文头包含若干个属性 格式为“属性名:属性值”
  - 响应正文
    - 响应报文体，我们需要的内容，多种形式比如html、json、图片、视频文件等

![image-20200523224403332](https://file.xdclass.net/note/2022/77QD/img/image-20200523224403332.png)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 第4集 HTTP的九种请求方法介绍

**简介：讲解http常见的请求方法和使用**

- http1.0定义了三种：
  - GET: 向服务器获取资源，比如常见的查询请求
  - POST: 向服务器提交数据而发送的请求
  - Head: 和get类似，返回的响应中没有具体的内容，用于获取报头
- http1.1定义了六种
  - PUT：一般是用于更新请求，比如更新个人信息、商品信息全量更新
  - PATCH：PUT 方法的补充,更新指定资源的部分数据
  - DELETE：用于删除指定的资源
  - OPTIONS: 获取服务器支持的HTTP请求方法，服务器性能、跨域检查等
  - CONNECT: 方法的作用就是把服务器作为跳板，让服务器代替用户去访问其它网页，之后把数据原原本本的返回给用户，网页开发基本不用这个方法，如果是http代理就会使用这个，让服务器代理用户去访问其他网页，类似中介
  - TRACE：回显服务器收到的请求，主要用于测试或诊断

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 第5集 Http常见响应状态码HttpCode

**简介：Http常见的响应状态码讲解**

- 浏览器向服务器请求时，服务端响应的消息头里面有状态码，表示请求结果的状态

- 分类

  - 1XX

    - 100 收到请求，需要请求者继续执行操作，比较少用

    - 101 切换请求的协议

       

  - 2XX: 请求成功，常用的 200

   

  - 3XX: 重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取；

    - 好处：网站改版、域名迁移等，多个域名指向同个主站导流

    - 必须记住： 301：永久性跳转，比如域名过期，换个域名 302：临时性跳转

      304：数据已经在客户端缓存，不需要请求更多的数据

     

  - 4XX: 客服端出错，请求包含语法错误或者无法完成请求

    - 必须记住： 400: 请求出错，比如语法协议 403: 没权限访问 404: 找不到这个路径对应的接口或者文件 405: 不允许此方法进行提交，Method not allowed，比如接口一定要POST方式，而你是用了GET

       

  - 5XX: 服务端出错，服务器在处理请求的过程中发生了错误

    - 必须记住： 500: 服务器内部报错了，完成不了这次请求 503: 服务器宕机

 

 

 

 

 

#### 第6集 Http请求头知识点讲解

**简介：讲解http常见请求头讲解**

- http请求分为三部分：请求行，请求头， 请求体
- 请求头
  - 报文头包含若干个属性 格式为“属性名:属性值”，
  - 服务端据此获取客户端的基本信息
- 常见的请求头
  - Accept： 浏览器支持的 MIME 媒体类型, 比如 text/html,application/json,image/webp,*/* 等
  - Accept-Encoding: 浏览器发给服务器，声明浏览器支持的编码类型，gzip, deflate
  - Accept-Language: 客户端接受的语言格式，比如 zh-CN
  - Connection: keep-alive，开启HTTP持久连接，复用传输通道
  - Host：服务器的域名
  - Origin：告诉服务器请求从哪里发起的，仅包括协议和域名 CORS跨域请求中可以看到response有对应的header，Access-Control-Allow-Origin
  - Referer：告诉服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数； 很多抢购服务会用这个做限制，必须通过某个入口进来才有效
  - User-Agent: 服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等； 风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考
  - Cookie: 表示服务端给客户端传的http请求状态,也是多个key=value形式组合，比如登录后的令牌等
  - Content-Type： HTTP请求提交的内容类型，一般只有post提交时才需要设置，浏览器把form数据封装到请求体中（key=value形式），然后发送到服务器，比如文件上传，表单提交等

 

 

 

 

 

 

 

 

 

 

 

 

 

#### 第7集 Http响应头知识点讲解

**简介：讲解Http响应头知识点**

- 响应头
  - 报文头包含若干个属性 格式为“属性名:属性值”
- 常见的响应头
  - Allow: 服务器支持哪些请求方法
  - Content-Length: 响应体的字节长度
  - Content-Type: 响应体的MIME类型
  - Content-Encoding: 设置数据使用的编码类型
  - Date: 设置消息发送的日期和时间
  - Expires: 设置响应体的过期时间,一个GMT时间，表示该缓存的有效时间
  - cache-control: Expires的作用一致，都是指明当前资源的有效期, 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,优先级高于Expires,控制粒度更细，如max-age=3600，即一个小时
  - Location：表示客户端应当到哪里去获取资源，一般同时设置状态代码为3xx
  - Server: 服务器名称
  - Transfer-Encoding：chunked 表示输出的内容长度不能确定，静态网页一般没有，基本出现在动态网页里面
  - Access-Control-Allow-Origin: 定哪些站点可以参与跨站资源共享

 

 

 

 

 

#### 第8集 你知道浏览器输入url后经历了哪些流程？

**简介：浏览器网络请求链路**

- 考点：是否掌握http请求产生到响应的链路
- 难度：【***】

- 说下常用浏览器输入一个url到用户看到结果，中间经过哪些流程

  ```
     1、浏览器输入url, 解析url地址是否合法
  ```

  ```
  　　2、浏览器检查是否有缓存, 如果有直接显示。如果没有跳到第三步
  ```

  ```
  　　3、在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址
  ```

  ```
  　　4、浏览器向服务器发起tcp链接，完成tcp三次握手
  ```

  ```
  　　5、握手成功后，浏览器向服务器发送http请求
  ```

  ```
  　　6、服务器收到处理的请求，将数据返回至浏览器
  ```

  ```
  　　7、浏览器收到http响应
  ```

  ```
  　　8、四次挥手（TCP）
  ```

  ```
  　　9、浏览器解析响应。如果响应可以缓存，则存入缓存
  ```

  ```
  　　10、浏览器进行页面渲染
  ```

   

- 浏览器页面渲染

  - 浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree

  - 与此同时，进行CSS解析，生成CSS Tree

  - 接着将DOM Tree与CSS Tree合成为 Render Tree

  - 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标

  - 随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来

     

  ![image-20220314105603659](https://file.xdclass.net/note/2022/77QD/img/image-20220314105603659.png)

 

 

 



### 第九章 面试大厂必问的前端性能优化知多少

#### 第1集 前端性能优化思路是怎样的？

- 考点：性能优化思路

- 难度【***】

- 性能优化思路

  - 先确认前端性能影响最大的问题

    - 网络连接速度

      - CDN

      - DNS预解析

        ```
        <link rel="dns-prefecth" href="https://xdclass.net">
        ```

      - 持久连接

        ```
        connection: keep-alive
        ```

    - 网络请求数量

      - 文件合并（webpack）
      - 图片处理
        - 雪碧图
        - base64
      - 使用缓存

    - 资源文件的体积

      - 压缩
      - 开启gzip

    - 资源加载

      - 加载位置
        - css文件放在head中
        - js文件放在body结束标签前
      - 加载时机
        - 异步script标签加载，设置defer、async

    - webpack优化

      - 打包公共代码
      - 动态导入
      - 长缓存优化
        - chunkhash
        - contenthash

 

 

 

#### 第2集 你了解前端的CDN性能优化吗？

**简介：理解CDN内容分发网络**

- 考点：CDN内容分发网络

- 难度【***】

- CDN

  - 阿里云CDN

    - https://help.aliyun.com/document_detail/27101.html

  - 定义

    CDN（内容分发网络）是通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将资源文件（音乐、图片、视频、应用程序）发送给用户，来提供高性能、低成本的网络内容传递给用户，提高请求的速度

     

  - 作用

    - 将数据快速可靠的从源服务站传递到用户端
    - 通过CDN，用户可以不直接从源站获取，选择一个较优的服务器获取数据，做到快速访问，减少源站负载压力
    - 其他作用
      - 监控
      - 统计分析
      - 用量查询
      - 刷新预热
      - 日志分析

     

     

  - 工作原理

    - 未使用CDN缓存资源

      - 浏览器通过DNS对域名进行解析，得到域名对应的IP地址

      - 浏览器根据得到的IP地址，向域名的服务主机发送数据请求

      - 服务器向浏览器返回响应数据

        ![image-20220315170332430](https://file.xdclass.net/note/2022/77QD/img/image-20220315170332430.png)

     

     

    - 使用CDN缓存资源
      - 用户发起域名的请求，DNS服务器将域名解析交给CDN
      - CDN将负载均衡的ip地址返回给用户
      - 请求地址，负载均衡设备选择一台最优的缓存服务器（边缘节点服务器）提供访问
        - 根据用户的ip地址，距离用户最近的服务器
        - 根据URL携带的内容，选择有所需内容的服务器
        - 选择负载最小的服务器
      - 用户发出请求，缓存服务器返回数据
      - 如果缓存服务器没有缓存用户的请求内容，则会向上一级缓存服务器请求，直到访问网站的源服务器

     

![image-20220315172305732](https://file.xdclass.net/note/2022/77QD/img/image-20220315172305732.png)

- 回源率（拓展知识点）

  ```
  回源率=（CDN没缓存+缓存过期+不可缓存的请求）/ 全部的请求
  ```

  - 回源率越低代表请求的性能越好

 

 

 

 

#### 第3集 懒加载是如何实现的？

**简介：懒加载**

- 考点：懒加载

- 难度【**】

- 描述

  - 懒加载也叫做延迟加载、按需加载，在非首屏展示的组件或者数据可以使用懒加载

- 特点

  - 减小接口请求个数，页面的渲染负担

  - 提高首页的展示速度，提升用户体验

  - 防止加载过多图片而影响其他资源文件的加载

     

- 实现

  - 通过 import() 方法引入组件

    ```
    import(./test.js).then(({fun})=>{fun()})
    ```

    ```
    ()=>import('./Test')
    ```

  - 通过监听用户的滚动事件触发来展示非首屏的图片

     

- 懒加载和预加载的区别

  - 懒加载也叫延迟加载，指的是在网页中延迟加载图片的时机，当用户需要访问时，再去加载，可以提高网站的首屏加载速度，提升用户的体验
  - 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源，通过预加载能够减少用户的等待时间，提高用户的体验

 

- 非首屏的内容延时渲染实现

  ```
  // 定义一个异步的函数，当用户滑动时则不延时
  ```

  ```
  const delayMS = (ms) => {
  ```

  ```
    const p = new Promise((resolve) => {
  ```

  ```
      setTimeout(resolve, ms);
  ```

  ```
    });
  ```

  ```
    // 如果用户开始滑动，则取消延期
  ```

  ```
    const onTouchPromise = new Promise((resolve) => {
  ```

  ```
      const handler = function () {
  ```

  ```
        window.removeEventListener('touchstart', handler);
  ```

  ```
        resolve();
  ```

  ```
      };
  ```

  ```
      window.addEventListener('touchstart', handler);
  ```

  ```
    });
  ```

  ```
    return Promise.race([p, onTouchPromise]);
  ```

  ```
  };
  ```

  ```
  
  ```

  ```
  // 引用
  ```

  ```
  
  ```

  ```
  delayMS(2000).then(() => {
  ```

  ```
    console.log(333); // 控制非首屏dom节点的渲染
  ```

  ```
  });
  ```

   

 

 

#### 第4集 项目中的图片优化怎么做？

**简介：图片优化**

- 考点：图片优化

- 难度【**】

- 如何对项目图片进行优化

  - 图片可以使用 CDN 加载，通过CDN地址获取

  - 图片比较小的使用webpack压缩成 base64 格式，减小项目文件体积

    - 实现

      ```
      {
      ```

      ```
        test: /\.(png|gif|jpe?g)$/i,
      ```

      ```
        type: 'asset',              
      ```

      ```
        parser: {
      ```

      ```
          dataUrlCondition: {
      ```

      ```
            maxSize: 8 * 1024,
      ```

      ```
          },
      ```

      ```
        },
      ```

      ```
        generator: {
      ```

      ```
          filename: 'images/[name][ext]',
      ```

      ```
        },
      ```

      ```
      },
      ```

       

  - icon尽量使用svg图片和字体图片，减小项目文件体积

 

 

 

#### 第5集 怎么通过webpack优化项目文件

**简介：webpack优化**

- 考点：webpack

- 难度【***】

- webpack抽离公共文件

  - 作用

    - 将多个页面重复引入的模块抽离成公共的模块，避免重复打包，减少包体积

  - 配置

    ```
    optimization: {
    ```

    ```
      splitChunks: {
    ```

    ```
        chunks: 'all',
    ```

    ```
      },
    ```

    ```
    },
    ```

     

- 可视化工具

  - 安装

    ```
    cnpm install webpack-bundle-analyzer -D
    ```

  - 配置

    ```
    // webpack.config.js
    ```

    ```
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
    ```

    ```
    module.exports = {
    ```

    ```
        plugins: [new BundleAnalyzerPlugin()]
    ```

    ```
    }
    ```

  - 图示

     

 

 

 

 

### 第十章 小滴课堂编写面试BAT大厂高级工程师简历

#### 第1集 你知道怎么编写一份合格的校招+初级+高级工程师简历吗？

**简介：简历常见的模块，哪些应该写，哪些不应该写**

- 个人信息
- 教育经历
- 技术栈
- 工作经历
- 个人评价

 

 

 

 

 

 

#### 第2集 简历项目经验讲解之在线教育视频模块功能

**简介：讲解视频模块功能**

![image-20220317145638976](https://file.xdclass.net/note/2022/77QD/img/image-20220317145638976.png)

#### 第3集 简历项目经验之官网支付模块功能

**简介：概述官网支付模块功能**

![image-20220317162610900](https://file.xdclass.net/note/2022/77QD/img/image-20220317162610900.png)

 

 

 

 

 

 

 
